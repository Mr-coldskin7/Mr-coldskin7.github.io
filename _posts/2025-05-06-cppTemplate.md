---
title: C++ Template
date: 2025-05-06 10:22:00 +0800
categories: [Cpp,template]
tags: [study]
---
# C++模板核心知识总结
## 一、模板概述
​​核心思想​​：泛型编程（编写与类型无关的通用代码）
​​解决的问题​​：代码复用性低、维护性差的问题（替代大量重复的函数重载）
​​分类​​：
函数模板（生成不同类型的具体函数）
类模板（生成不同类型的具体类）
## 二、函数模板
### 1. 基本格式
```cpp
template<typename T>  // 或 template<class T>
```

返回类型 函数名(参数列表) { ... }
### 2. 使用示例
```cpp
template<class T>
void Swap(T& a, T& b) {
    T tmp = a;
    a = b;
    b = tmp;
}
```
### 3. 核心原理
​​编译期实例化​​：编译器根据调用参数类型生成具体函数
​​生成机制​​：每个不同类型参数都会生成独立函数（通过反汇编可见不同地址）
### 4. 实例化方式
类型	说明	示例
隐式实例化	编译器自动推导类型	Swap(a, b)
显式实例化	手动指定类型	Swap<int>(a, b)
### 5. 匹配规则
优先匹配普通函数
若模板能生成更匹配的版本则选模板

支持多模板参数：template<class T1, class T2>
三、类模板
### 6. 基本格式
```cpp
template<class T>
class 类名 {
    // 成员定义
};
```

### 7. 使用示例（栈类）
```cpp
template<class T>
class Stack {
public:
    Stack(int capacity = 4);
    void Push(T data);
    ~Stack();
private:
    T* _array;
    int _capacity;
    int _size;
};
```
### 8. 关键特性
​​实例化方式​​：必须显式指定类型 `Stack<int> s;`
​​类名与类型​​：
Stack 是模板名
`Stack<int> `是实际类型


### 9. 分离编译问题
​​问题现象​​：声明与实现分离会导致链接错误
​​解决方案​​：
声明和定义写在同一个头文件中
显式实例化模板类（不推荐）
## 四、模板使用技巧
​​参数推导失败时​​：
强制类型转换 Add(a, (int)d)
显式实例化 `Add<int>(a, d)`
​​多模板参数应用​​：
```cpp
template<class K, class V>
void PrintPair(const K& key, const V& value) {
    cout << key << ":" << value << endl;
}
```
​​
## 五、总结
| 特性         | 函数模板                   | 类模板                     |
|--------------|---------------------------|---------------------------|
| 实例化方式    | 支持隐式/显式实例化        | 必须显式实例化             |
| 类型依赖      | 通过参数推导类型           | 需显式指定模板类型         |
| 编译机制      | 按调用类型生成具体函数      | 按指定类型生成具体类       |
| 典型应用      | 通用算法（如 `swap` `add`）| 容器类（如 `vector` `stack`）|

​​### 核心优势​​
大幅提升代码复用性
增强代码可维护性
支持泛型程序设计

​​### 注意事项​​
模板不支持分离编译（声明/定义需在同一文件）
类模板成员函数需定义为模板函数
避免过度模板化导致编译时间增加

